// DEBUG MODE
var SW_MAIN    = ";;;/* run in service worker */\nvar URL_MAP =\n{\n  \"2019/03/20/hello-world/index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/2019/03/20/hello-world/index.html\",\n    \"cdn\": \"\"\n  },\n  \"archives/2019/03/index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/archives/2019/03/index.html\",\n    \"cdn\": \"\"\n  },\n  \"archives/2019/index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/archives/2019/index.html\",\n    \"cdn\": \"\"\n  },\n  \"archives/index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/archives/index.html\",\n    \"cdn\": \"\"\n  },\n  \"css/aloha.css\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/aloha.css\",\n    \"cdn\": \"\"\n  },\n  \"css/aloha.less\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/aloha.less\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/semantic.min.css\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/semantic.min.css\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.eot\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.eot\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.svg\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.svg\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.ttf\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.ttf\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff2\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff2\",\n    \"cdn\": \"\"\n  },\n  \"favicon.ico\": {\n    \"url\": \"https://geziang.github.io/blog_published/favicon.ico\",\n    \"cdn\": \"\"\n  },\n  \"images/algolia_logo.svg\": {\n    \"url\": \"https://geziang.github.io/blog_published/images/algolia_logo.svg\",\n    \"cdn\": \"\"\n  },\n  \"images/avatar.jpg\": {\n    \"url\": \"https://geziang.github.io/blog_published/images/avatar.jpg\",\n    \"cdn\": \"\"\n  },\n  \"images/scrolltop.png\": {\n    \"url\": \"https://geziang.github.io/blog_published/images/scrolltop.png\",\n    \"cdn\": \"\"\n  },\n  \"index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/index.html\",\n    \"cdn\": \"\"\n  },\n  \"js/aloha-events.js\": {\n    \"url\": \"https://geziang.github.io/blog_published/js/aloha-events.js\",\n    \"cdn\": \"\"\n  },\n  \"js/aloha.js\": {\n    \"url\": \"https://geziang.github.io/blog_published/js/aloha.js\",\n    \"cdn\": \"https://i.loli.net/2019/03/20/5c91f646251cd.png\"\n  },\n  \"js/imgencode.js\": {\n    \"url\": \"https://geziang.github.io/blog_published/js/imgencode.js\",\n    \"cdn\": \"\"\n  },\n  \"js/semantic-ui-algolia.js\": {\n    \"url\": \"https://geziang.github.io/blog_published/js/semantic-ui-algolia.js\",\n    \"cdn\": \"\"\n  }\n}\nasync function output(size, data, os) {\n  if (data.length < size) {\n    // TODO: error handler\n    console.warn('bad size');\n    os.close();\n    return;\n  }\n  os.enqueue(data);\n\n  os.close();\n  return -1;  // success\n}\n\nfunction parseImg(blob) {\n	return new Promise((resolve, reject) => {\n		self.clients.matchAll().then(clients => {\n			let client = clients[0];\n			\n			var msg_chan = new MessageChannel();\n			msg_chan.port1.onmessage = function(event){\n				console.log('sw port on message');\n				if(event.data.error){\n					reject(event.data.error);\n				}else{\n					resolve(event.data);\n				}\n			};\n\n			console.log('sw post to page');\n			client.postMessage(blob, [msg_chan.port2]);\n		})\n    })\n}\n\nasync function proxy(req, item) {\n  // TODO: choose fastest node, error retry\n  let cdn = item.cdn;\n  let url = item.url;\n\n  if (cdn == \"\") {\n	  let res = await fetch(url);\n	  return res;\n  }\n  \n  let res = await fetch(cdn);\n  let blob = await res.blob();\n  let obj = await parseImg(blob);\n  \n  if (!obj) {\n    let html = '500: Decode Failed';\n    return new Response(html, {\n      status: 500,\n      statusText: 'Decode Failed'\n    });\n  }\n  let ext = JSON.parse(obj.ext);\n  let data = obj.data;\n  let size = ext.size;\n  let mime = ext.mime;\n\n  // http respond\n  let headers = new Headers();\n  headers.set('content-type', mime);\n  headers.set('x-proxy', cdn);\n\n  // ostream <- my chunks\n  // istream -> Response\n  let os;\n  let is = new ReadableStream({\n    start(controller) {\n      os = controller;\n    }\n  });\n\n  res = new Response(is, {\n    headers: headers,\n  });\n\n  output(size, data, os);\n  return res;\n}\n\nexports.onfetch = function(e) {\n  let req = e.request;\n  let url = new URL(req.url);\n\n  let host = url.hostname;\n  if (host != \"percent73.xyz\") {\n	  let res = fetch(url);\n	  return res;\n  }\n  \n  let path = url.pathname;\n  if (path.endsWith('/')) {\n    path += 'index.html';\n  }\n\n  let item = URL_MAP[path.substr(1)];\n  if (!item) {\n    let html = '404: Not Found';\n\n    return new Response(html, {\n      status: 404,\n      statusText: 'Not Found'\n    });\n  }\n\n  return proxy(req, item);\n};\n\nexports.oninit = function(e) {\n  console.log('mod oninit');\n};\n\nexports.onterm = function(e) {\n  console.log('mod onterm');\n};;;;"
var SW_LOADER  = "/* run in service worker */\nconst EVENT_FETCH = 0;\nconst EVENT_MSG = 1;\n\nlet queue = [];\nlet swMod;\n\nfunction addQueue(v) {\n  queue.push(v);\n}\n\nfunction flushQueue() {\n  queue.forEach(args => {\n    let [type, e, y, n] = args;\n\n    switch (type) {\n    case EVENT_MSG:\n      swMod.onmsg(e);\n      break;\n\n    case EVENT_FETCH:\n      let p = swMod.onfetch(e);\n      if (!p) {\n        // sw bypass\n        p = fetch(e.request);\n      }\n      p.then(y).catch(n);\n      break;\n    }\n  });\n  queue = [];\n}\n\nself.onmessage = function(e) {\n  if (swMod) {\n    swMod.onmsg(e);\n  } else {\n    addQueue([EVENT_MSG, e]);\n  }\n};\n\nself.onfetch = function(e) {\n  let req = e.request;\n  let url = req.url;\n\n  console.log('[sw_loader] fetch {mode: %o, url: %o, hdr: %o}',\n    req.mode, url, new Map(req.headers)\n  );\n\n  // force update\n  if (url.endsWith('/--update')) {\n    load(true);\n    let res = new Response('UPDATED');\n    e.respondWith(res);\n    return;\n  }\n\n  // bypass Mixed-Content (except localhost)\n  if (url.startsWith('http:') && !url.startsWith('http://127.0.0.1')) {\n    return;\n  }\n\n  let ret;\n\n  if (swMod) {\n    ret = swMod.onfetch(e);\n  } else {\n    ret = new Promise((y, n) => {\n      addQueue([EVENT_FETCH, e, y, n]);\n    });\n  }\n\n  if (ret) {\n    e.respondWith(ret);\n  }\n};\n\nself.onactivate = function(e) {\n  console.log('[sw_loader] onactivate');\n};\n\nself.oninstall = function(e) {\n  console.log('[sw_loader] oninstall');\n  skipWaiting();\n};\n\nfunction run(code) {\n  let exports = {};\n\n  let fn = Function('exports', code);\n  fn(exports);\n\n  if (swMod) {\n    swMod.onterm();\n  }\n  swMod = exports;\n  swMod.oninit();\n\n  flushQueue();\n}\n\nfunction extractSwMain(code) {\n  let m = code.match(/\\;{3}.+?\\;{3}/);\n  return m && m[0]\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\\"/g, '\"')\n    .replace(/\\\\\\\\/g, '\\\\')\n}\n\nasync function load(isUpdate) {\n  let oldJs;\n  let cache = await caches.open('v1');\n  let req = new Request('/sw_main');\n  let res = await cache.match(req);\n\n  if (res) {\n    oldJs = await res.text();\n  } else {\n    // if cache missing, we use the default\n    // module which defined in boot.js\n    oldJs = SW_MAIN;\n  }\n\n  // init\n  if (!isUpdate) {\n    run(oldJs);\n    return;\n  }\n\n  // fetch latest version\n  let url = location.href;\n  if (isUpdate) {\n    url += '?_=' + Date.now();\n  }\n  res = await fetch(url);\n\n  // cache & run if sw_main modified\n  let newJs = await res.text();\n  let newSw = extractSwMain(newJs);\n  console.assert(newSw);\n\n  if (newSw !== SW_MAIN) {\n    cache.put(req, new Response(newSw));\n    run(newSw);\n    console.log('[sw_loader] sw_main updated');\n  } else {\n    console.log('[sw_loader] sw_main no updated');\n  }\n}\n\nload();"
var SW_INSTALL = "/* run in page */\n\nfunction reload() {\n  var curr = +new Date;\n  var last;\n  try {\n    last = +sessionStorage._ts || 0;\n  } catch (err) {\n    last = curr;\n  }\n\n  if (curr - last < 100) {\n    show('waiting...');\n    setTimeout(reload, 5000);\n    return;\n  }\n\n  try {\n    sessionStorage._ts = curr;\n  } catch (err) {\n  }\n  location.reload();\n}\n\nfunction show(s) {\n  var node = document.body || document.documentElement;\n  node.innerHTML = s;\n}\n\nfunction unsupport() {\n  show('Please use the latest Chrome');\n}\n\nfunction onfail(err) {\n  show(err);\n}\n\nfunction main() {\n  var sw = navigator.serviceWorker;\n  if (!sw) {\n    return unsupport();\n  }\n\n  var asynFlag;\n  try {\n    asynFlag = eval('async _=>_');\n  } catch(err) {\n  }\n\n  var streamFlag = self.ReadableStream;\n  //...\n\n  if (!asynFlag || !streamFlag) {\n    unsupport();\n    return;\n  }\n\n  let url = document.currentScript.src;\n  sw\n    .register(url)\n    .then(reload)\n    .catch(onfail);\n\n  sw.onerror = function(err) {\n    console.warn('sw err:', err);\n  };\n}\nmain();"

eval(self.window ? SW_INSTALL : SW_LOADER);