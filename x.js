// DEBUG MODE
var SW_MAIN    = ";;;/* run in service worker */\nvar URL_MAP =\n{\n  \"2019/03/20/hello-world/index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/2019/03/20/hello-world/index.html\",\n    \"cdn\": \"\"\n  },\n  \"archives/2019/03/index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/archives/2019/03/index.html\",\n    \"cdn\": \"\"\n  },\n  \"archives/2019/index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/archives/2019/index.html\",\n    \"cdn\": \"\"\n  },\n  \"archives/index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/archives/index.html\",\n    \"cdn\": \"\"\n  },\n  \"css/aloha.css\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/aloha.css\",\n    \"cdn\": \"https://i.loli.net/2019/03/21/5c9301efd253b.png\"\n  },\n  \"css/aloha.less\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/aloha.less\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/semantic.min.css\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/semantic.min.css\",\n    \"cdn\": \"https://i.loli.net/2019/03/21/5c93015cd8246.png\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.eot\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.eot\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.svg\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.svg\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.ttf\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.ttf\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff\",\n    \"cdn\": \"\"\n  },\n  \"css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff2\": {\n    \"url\": \"https://geziang.github.io/blog_published/css/semantic-ui/2.2.4/themes/default/assets/fonts/icons.woff2\",\n    \"cdn\": \"\"\n  },\n  \"favicon.ico\": {\n    \"url\": \"https://geziang.github.io/blog_published/favicon.ico\",\n    \"cdn\": \"\"\n  },\n  \"images/algolia_logo.svg\": {\n    \"url\": \"https://geziang.github.io/blog_published/images/algolia_logo.svg\",\n    \"cdn\": \"\"\n  },\n  \"images/avatar.jpg\": {\n    \"url\": \"https://geziang.github.io/blog_published/images/avatar.jpg\",\n    \"cdn\": \"\"\n  },\n  \"images/scrolltop.png\": {\n    \"url\": \"https://geziang.github.io/blog_published/images/scrolltop.png\",\n    \"cdn\": \"\"\n  },\n  \"index.html\": {\n    \"url\": \"https://geziang.github.io/blog_published/index.html\",\n    \"cdn\": \"\"\n  },\n  \"js/aloha-events.js\": {\n    \"url\": \"https://geziang.github.io/blog_published/js/aloha-events.js\",\n    \"cdn\": \"\"\n  },\n  \"js/aloha.js\": {\n    \"url\": \"https://geziang.github.io/blog_published/js/aloha.js\",\n    \"cdn\": \"https://i.loli.net/2019/03/20/5c91f646251cd.png\"\n  },\n  \"js/semantic-ui-algolia.js\": {\n    \"url\": \"https://geziang.github.io/blog_published/js/semantic-ui-algolia.js\",\n    \"cdn\": \"\"\n  }\n}\n/*\n * Extracted from pdf.js\n * https://github.com/andreasgal/pdf.js\n *\n * Copyright (c) 2011 Mozilla Foundation\n *\n * Contributors: Andreas Gal <gal@mozilla.com>\n *               Chris G Jones <cjones@mozilla.com>\n *               Shaon Barman <shaon.barman@gmail.com>\n *               Vivien Nicolas <21@vingtetun.org>\n *               Justin D'Arcangelo <justindarc@gmail.com>\n *               Yury Delendik\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\nvar DecodeStream = (function() {\n  function constructor() {\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = null;\n  }\n\n  constructor.prototype = {\n    ensureBuffer: function decodestream_ensureBuffer(requested) {\n      var buffer = this.buffer;\n      var current = buffer ? buffer.byteLength : 0;\n      if (requested < current)\n        return buffer;\n      var size = 512;\n      while (size < requested)\n        size <<= 1;\n      var buffer2 = new Uint8Array(size);\n      for (var i = 0; i < current; ++i)\n        buffer2[i] = buffer[i];\n      return this.buffer = buffer2;\n    },\n    getByte: function decodestream_getByte() {\n      var pos = this.pos;\n      while (this.bufferLength <= pos) {\n        if (this.eof)\n          return null;\n        this.readBlock();\n      }\n      return this.buffer[this.pos++];\n    },\n    getBytes: function decodestream_getBytes(length) {\n      var pos = this.pos;\n\n      if (length) {\n        this.ensureBuffer(pos + length);\n        var end = pos + length;\n\n        while (!this.eof && this.bufferLength < end)\n          this.readBlock();\n\n        var bufEnd = this.bufferLength;\n        if (end > bufEnd)\n          end = bufEnd;\n      } else {\n        while (!this.eof)\n          this.readBlock();\n\n        var end = this.bufferLength;\n      }\n\n      this.pos = end;\n      return this.buffer.subarray(pos, end);\n    },\n    lookChar: function decodestream_lookChar() {\n      var pos = this.pos;\n      while (this.bufferLength <= pos) {\n        if (this.eof)\n          return null;\n        this.readBlock();\n      }\n      return String.fromCharCode(this.buffer[this.pos]);\n    },\n    getChar: function decodestream_getChar() {\n      var pos = this.pos;\n      while (this.bufferLength <= pos) {\n        if (this.eof)\n          return null;\n        this.readBlock();\n      }\n      return String.fromCharCode(this.buffer[this.pos++]);\n    },\n    makeSubStream: function decodestream_makeSubstream(start, length, dict) {\n      var end = start + length;\n      while (this.bufferLength <= end && !this.eof)\n        this.readBlock();\n      return new Stream(this.buffer, start, length, dict);\n    },\n    skip: function decodestream_skip(n) {\n      if (!n)\n        n = 1;\n      this.pos += n;\n    },\n    reset: function decodestream_reset() {\n      this.pos = 0;\n    }\n  };\n\n  return constructor;\n})();\n\nvar FlateStream = (function() {\n  var codeLenCodeMap = new Uint32Array([\n    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\n  ]);\n\n  var lengthDecode = new Uint32Array([\n    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,\n    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,\n    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,\n    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102\n  ]);\n\n  var distDecode = new Uint32Array([\n    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,\n    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,\n    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,\n    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001\n  ]);\n\n  var fixedLitCodeTab = [new Uint32Array([\n    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,\n    0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,\n    0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,\n    0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,\n    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,\n    0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,\n    0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,\n    0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,\n    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,\n    0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,\n    0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,\n    0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,\n    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,\n    0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,\n    0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,\n    0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,\n    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,\n    0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,\n    0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,\n    0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,\n    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,\n    0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,\n    0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,\n    0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,\n    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,\n    0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,\n    0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,\n    0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,\n    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,\n    0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,\n    0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,\n    0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,\n    0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,\n    0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,\n    0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,\n    0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,\n    0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,\n    0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,\n    0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,\n    0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,\n    0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,\n    0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,\n    0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,\n    0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,\n    0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,\n    0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,\n    0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,\n    0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,\n    0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,\n    0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,\n    0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,\n    0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,\n    0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,\n    0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,\n    0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,\n    0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,\n    0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,\n    0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,\n    0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,\n    0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,\n    0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,\n    0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,\n    0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,\n    0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff\n  ]), 9];\n\n  var fixedDistCodeTab = [new Uint32Array([\n    0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,\n    0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,\n    0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,\n    0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000\n  ]), 5];\n  \n  function error(e) {\n      throw new Error(e)\n  }\n\n  function constructor(bytes) {\n    //var bytes = stream.getBytes();\n    var bytesPos = 0;\n\n    var cmf = bytes[bytesPos++];\n    var flg = bytes[bytesPos++];\n    if (cmf == -1 || flg == -1)\n      error('Invalid header in flate stream');\n    if ((cmf & 0x0f) != 0x08)\n      error('Unknown compression method in flate stream');\n    if ((((cmf << 8) + flg) % 31) != 0)\n      error('Bad FCHECK in flate stream');\n    if (flg & 0x20)\n      error('FDICT bit set in flate stream');\n\n    this.bytes = bytes;\n    this.bytesPos = bytesPos;\n\n    this.codeSize = 0;\n    this.codeBuf = 0;\n\n    DecodeStream.call(this);\n  }\n\n  constructor.prototype = Object.create(DecodeStream.prototype);\n\n  constructor.prototype.getBits = function(bits) {\n    var codeSize = this.codeSize;\n    var codeBuf = this.codeBuf;\n    var bytes = this.bytes;\n    var bytesPos = this.bytesPos;\n\n    var b;\n    while (codeSize < bits) {\n      if (typeof (b = bytes[bytesPos++]) == 'undefined')\n        error('Bad encoding in flate stream');\n      codeBuf |= b << codeSize;\n      codeSize += 8;\n    }\n    b = codeBuf & ((1 << bits) - 1);\n    this.codeBuf = codeBuf >> bits;\n    this.codeSize = codeSize -= bits;\n    this.bytesPos = bytesPos;\n    return b;\n  };\n\n  constructor.prototype.getCode = function(table) {\n    var codes = table[0];\n    var maxLen = table[1];\n    var codeSize = this.codeSize;\n    var codeBuf = this.codeBuf;\n    var bytes = this.bytes;\n    var bytesPos = this.bytesPos;\n\n    while (codeSize < maxLen) {\n      var b;\n      if (typeof (b = bytes[bytesPos++]) == 'undefined')\n        error('Bad encoding in flate stream');\n      codeBuf |= (b << codeSize);\n      codeSize += 8;\n    }\n    var code = codes[codeBuf & ((1 << maxLen) - 1)];\n    var codeLen = code >> 16;\n    var codeVal = code & 0xffff;\n    if (codeSize == 0 || codeSize < codeLen || codeLen == 0)\n      error('Bad encoding in flate stream');\n    this.codeBuf = (codeBuf >> codeLen);\n    this.codeSize = (codeSize - codeLen);\n    this.bytesPos = bytesPos;\n    return codeVal;\n  };\n\n  constructor.prototype.generateHuffmanTable = function(lengths) {\n    var n = lengths.length;\n\n    // find max code length\n    var maxLen = 0;\n    for (var i = 0; i < n; ++i) {\n      if (lengths[i] > maxLen)\n        maxLen = lengths[i];\n    }\n\n    // build the table\n    var size = 1 << maxLen;\n    var codes = new Uint32Array(size);\n    for (var len = 1, code = 0, skip = 2;\n         len <= maxLen;\n         ++len, code <<= 1, skip <<= 1) {\n      for (var val = 0; val < n; ++val) {\n        if (lengths[val] == len) {\n          // bit-reverse the code\n          var code2 = 0;\n          var t = code;\n          for (var i = 0; i < len; ++i) {\n            code2 = (code2 << 1) | (t & 1);\n            t >>= 1;\n          }\n\n          // fill the table entries\n          for (var i = code2; i < size; i += skip)\n            codes[i] = (len << 16) | val;\n\n          ++code;\n        }\n      }\n    }\n\n    return [codes, maxLen];\n  };\n\n  constructor.prototype.readBlock = function() {\n    function repeat(stream, array, len, offset, what) {\n      var repeat = stream.getBits(len) + offset;\n      while (repeat-- > 0)\n        array[i++] = what;\n    }\n\n    // read block header\n    var hdr = this.getBits(3);\n    if (hdr & 1)\n      this.eof = true;\n    hdr >>= 1;\n\n    if (hdr == 0) { // uncompressed block\n      var bytes = this.bytes;\n      var bytesPos = this.bytesPos;\n      var b;\n\n      if (typeof (b = bytes[bytesPos++]) == 'undefined')\n        error('Bad block header in flate stream');\n      var blockLen = b;\n      if (typeof (b = bytes[bytesPos++]) == 'undefined')\n        error('Bad block header in flate stream');\n      blockLen |= (b << 8);\n      if (typeof (b = bytes[bytesPos++]) == 'undefined')\n        error('Bad block header in flate stream');\n      var check = b;\n      if (typeof (b = bytes[bytesPos++]) == 'undefined')\n        error('Bad block header in flate stream');\n      check |= (b << 8);\n      if (check != (~blockLen & 0xffff))\n        error('Bad uncompressed block length in flate stream');\n\n      this.codeBuf = 0;\n      this.codeSize = 0;\n\n      var bufferLength = this.bufferLength;\n      var buffer = this.ensureBuffer(bufferLength + blockLen);\n      var end = bufferLength + blockLen;\n      this.bufferLength = end;\n      for (var n = bufferLength; n < end; ++n) {\n        if (typeof (b = bytes[bytesPos++]) == 'undefined') {\n          this.eof = true;\n          break;\n        }\n        buffer[n] = b;\n      }\n      this.bytesPos = bytesPos;\n      return;\n    }\n\n    var litCodeTable;\n    var distCodeTable;\n    if (hdr == 1) { // compressed block, fixed codes\n      litCodeTable = fixedLitCodeTab;\n      distCodeTable = fixedDistCodeTab;\n    } else if (hdr == 2) { // compressed block, dynamic codes\n      var numLitCodes = this.getBits(5) + 257;\n      var numDistCodes = this.getBits(5) + 1;\n      var numCodeLenCodes = this.getBits(4) + 4;\n\n      // build the code lengths code table\n      var codeLenCodeLengths = Array(codeLenCodeMap.length);\n      var i = 0;\n      while (i < numCodeLenCodes)\n        codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);\n      var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);\n\n      // build the literal and distance code tables\n      var len = 0;\n      var i = 0;\n      var codes = numLitCodes + numDistCodes;\n      var codeLengths = new Array(codes);\n      while (i < codes) {\n        var code = this.getCode(codeLenCodeTab);\n        if (code == 16) {\n          repeat(this, codeLengths, 2, 3, len);\n        } else if (code == 17) {\n          repeat(this, codeLengths, 3, 3, len = 0);\n        } else if (code == 18) {\n          repeat(this, codeLengths, 7, 11, len = 0);\n        } else {\n          codeLengths[i++] = len = code;\n        }\n      }\n\n      litCodeTable =\n        this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));\n      distCodeTable =\n        this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));\n    } else {\n      error('Unknown block type in flate stream');\n    }\n\n    var buffer = this.buffer;\n    var limit = buffer ? buffer.length : 0;\n    var pos = this.bufferLength;\n    while (true) {\n      var code1 = this.getCode(litCodeTable);\n      if (code1 < 256) {\n        if (pos + 1 >= limit) {\n          buffer = this.ensureBuffer(pos + 1);\n          limit = buffer.length;\n        }\n        buffer[pos++] = code1;\n        continue;\n      }\n      if (code1 == 256) {\n        this.bufferLength = pos;\n        return;\n      }\n      code1 -= 257;\n      code1 = lengthDecode[code1];\n      var code2 = code1 >> 16;\n      if (code2 > 0)\n        code2 = this.getBits(code2);\n      var len = (code1 & 0xffff) + code2;\n      code1 = this.getCode(distCodeTable);\n      code1 = distDecode[code1];\n      code2 = code1 >> 16;\n      if (code2 > 0)\n        code2 = this.getBits(code2);\n      var dist = (code1 & 0xffff) + code2;\n      if (pos + len >= limit) {\n        buffer = this.ensureBuffer(pos + len);\n        limit = buffer.length;\n      }\n      for (var k = 0; k < len; ++k, ++pos)\n        buffer[pos] = buffer[pos - dist];\n    }\n  };\n\n  return constructor;\n})();// Generated by CoffeeScript 1.4.0\n\n/*\n# MIT LICENSE\n# Copyright (c) 2011 Devon Govett\n# \n# Permission is hereby granted, free of charge, to any person obtaining a copy of this \n# software and associated documentation files (the \"Software\"), to deal in the Software \n# without restriction, including without limitation the rights to use, copy, modify, merge, \n# publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons \n# to whom the Software is furnished to do so, subject to the following conditions:\n# \n# The above copyright notice and this permission notice shall be included in all copies or \n# substantial portions of the Software.\n# \n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING \n# BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND \n# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar PNG;\n\nPNG = (function() {\n	var APNG_BLEND_OP_OVER, APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_NONE, APNG_DISPOSE_OP_PREVIOUS;\n\n	APNG_DISPOSE_OP_NONE = 0;\n\n	APNG_DISPOSE_OP_BACKGROUND = 1;\n\n	APNG_DISPOSE_OP_PREVIOUS = 2;\n\n	APNG_BLEND_OP_SOURCE = 0;\n\n	APNG_BLEND_OP_OVER = 1;\n\n	function PNG(data) {\n	  var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, short, text, _i, _j, _ref;\n	  this.data = data;\n	  this.pos = 8;\n	  this.palette = [];\n	  this.imgData = [];\n	  this.transparency = {};\n	  this.animation = null;\n	  this.text = {};\n	  frame = null;\n	  while (true) {\n		chunkSize = this.readUInt32();\n		section = ((function() {\n		  var _i, _results;\n		  _results = [];\n		  for (i = _i = 0; _i < 4; i = ++_i) {\n			_results.push(String.fromCharCode(this.data[this.pos++]));\n		  }\n		  return _results;\n		}).call(this)).join('');\n		switch (section) {\n		  case 'IHDR':\n			this.width = this.readUInt32();\n			this.height = this.readUInt32();\n			this.bits = this.data[this.pos++];\n			this.colorType = this.data[this.pos++];\n			this.compressionMethod = this.data[this.pos++];\n			this.filterMethod = this.data[this.pos++];\n			this.interlaceMethod = this.data[this.pos++];\n			break;\n		  case 'acTL':\n			this.animation = {\n			  numFrames: this.readUInt32(),\n			  numPlays: this.readUInt32() || Infinity,\n			  frames: []\n			};\n			break;\n		  case 'PLTE':\n			this.palette = this.read(chunkSize);\n			break;\n		  case 'fcTL':\n			if (frame) {\n			  this.animation.frames.push(frame);\n			}\n			this.pos += 4;\n			frame = {\n			  width: this.readUInt32(),\n			  height: this.readUInt32(),\n			  xOffset: this.readUInt32(),\n			  yOffset: this.readUInt32()\n			};\n			delayNum = this.readUInt16();\n			delayDen = this.readUInt16() || 100;\n			frame.delay = 1000 * delayNum / delayDen;\n			frame.disposeOp = this.data[this.pos++];\n			frame.blendOp = this.data[this.pos++];\n			frame.data = [];\n			break;\n		  case 'IDAT':\n		  case 'fdAT':\n			if (section === 'fdAT') {\n			  this.pos += 4;\n			  chunkSize -= 4;\n			}\n			data = (frame != null ? frame.data : void 0) || this.imgData;\n			for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {\n			  data.push(this.data[this.pos++]);\n			}\n			break;\n		  case 'tRNS':\n			this.transparency = {};\n			switch (this.colorType) {\n			  case 3:\n				this.transparency.indexed = this.read(chunkSize);\n				short = 255 - this.transparency.indexed.length;\n				if (short > 0) {\n				  for (i = _j = 0; 0 <= short ? _j < short : _j > short; i = 0 <= short ? ++_j : --_j) {\n					this.transparency.indexed.push(255);\n				  }\n				}\n				break;\n			  case 0:\n				this.transparency.grayscale = this.read(chunkSize)[0];\n				break;\n			  case 2:\n				this.transparency.rgb = this.read(chunkSize);\n			}\n			break;\n		  case 'tEXt':\n			text = this.read(chunkSize);\n			index = text.indexOf(0);\n			key = String.fromCharCode.apply(String, text.slice(0, index));\n			this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n			break;\n		  case 'IEND':\n			if (frame) {\n			  this.animation.frames.push(frame);\n			}\n			this.colors = (function() {\n			  switch (this.colorType) {\n				case 0:\n				case 3:\n				case 4:\n				  return 1;\n				case 2:\n				case 6:\n				  return 3;\n			  }\n			}).call(this);\n			this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;\n			colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n			this.pixelBitlength = this.bits * colors;\n			this.colorSpace = (function() {\n			  switch (this.colors) {\n				case 1:\n				  return 'DeviceGray';\n				case 3:\n				  return 'DeviceRGB';\n			  }\n			}).call(this);\n			this.imgData = new Uint8Array(this.imgData);\n			return;\n		  default:\n			this.pos += chunkSize;\n		}\n		this.pos += 4;\n		if (this.pos > this.data.length) {\n		  throw new Error(\"Incomplete or corrupt PNG file\");\n		}\n	  }\n	  return;\n	}\n\n	PNG.prototype.read = function(bytes) {\n	  var i, _i, _results;\n	  _results = [];\n	  for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {\n		_results.push(this.data[this.pos++]);\n	  }\n	  return _results;\n	};\n\n	PNG.prototype.readUInt32 = function() {\n	  var b1, b2, b3, b4;\n	  b1 = this.data[this.pos++] << 24;\n	  b2 = this.data[this.pos++] << 16;\n	  b3 = this.data[this.pos++] << 8;\n	  b4 = this.data[this.pos++];\n	  return b1 | b2 | b3 | b4;\n	};\n\n	PNG.prototype.readUInt16 = function() {\n	  var b1, b2;\n	  b1 = this.data[this.pos++] << 8;\n	  b2 = this.data[this.pos++];\n	  return b1 | b2;\n	};\n\n	PNG.prototype.decodePixels = function(data) {\n	  var byte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;\n	  if (data == null) {\n		data = this.imgData;\n	  }\n	  if (data.length === 0) {\n		return new Uint8Array(0);\n	  }\n	  data = new FlateStream(data);\n	  data = data.getBytes();\n	  pixelBytes = this.pixelBitlength / 8;\n	  scanlineLength = pixelBytes * this.width;\n	  pixels = new Uint8Array(scanlineLength * this.height);\n	  length = data.length;\n	  row = 0;\n	  pos = 0;\n	  c = 0;\n	  while (pos < length) {\n		switch (data[pos++]) {\n		  case 0:\n			for (i = _i = 0; _i < scanlineLength; i = _i += 1) {\n			  pixels[c++] = data[pos++];\n			}\n			break;\n		  case 1:\n			for (i = _j = 0; _j < scanlineLength; i = _j += 1) {\n			  byte = data[pos++];\n			  left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n			  pixels[c++] = (byte + left) % 256;\n			}\n			break;\n		  case 2:\n			for (i = _k = 0; _k < scanlineLength; i = _k += 1) {\n			  byte = data[pos++];\n			  col = (i - (i % pixelBytes)) / pixelBytes;\n			  upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];\n			  pixels[c++] = (upper + byte) % 256;\n			}\n			break;\n		  case 3:\n			for (i = _l = 0; _l < scanlineLength; i = _l += 1) {\n			  byte = data[pos++];\n			  col = (i - (i % pixelBytes)) / pixelBytes;\n			  left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n			  upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];\n			  pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n			}\n			break;\n		  case 4:\n			for (i = _m = 0; _m < scanlineLength; i = _m += 1) {\n			  byte = data[pos++];\n			  col = (i - (i % pixelBytes)) / pixelBytes;\n			  left = i < pixelBytes ? 0 : pixels[c - pixelBytes];\n			  if (row === 0) {\n				upper = upperLeft = 0;\n			  } else {\n				upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];\n				upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + (i % pixelBytes)];\n			  }\n			  p = left + upper - upperLeft;\n			  pa = Math.abs(p - left);\n			  pb = Math.abs(p - upper);\n			  pc = Math.abs(p - upperLeft);\n			  if (pa <= pb && pa <= pc) {\n				paeth = left;\n			  } else if (pb <= pc) {\n				paeth = upper;\n			  } else {\n				paeth = upperLeft;\n			  }\n			  pixels[c++] = (byte + paeth) % 256;\n			}\n			break;\n		  default:\n			throw new Error(\"Invalid filter algorithm: \" + data[pos - 1]);\n		}\n		row++;\n	  }\n	  return pixels;\n	};\n\n	PNG.prototype.decodePalette = function() {\n	  var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;\n	  palette = this.palette;\n	  transparency = this.transparency.indexed || [];\n	  ret = new Uint8Array((transparency.length || 0) + palette.length);\n	  pos = 0;\n	  length = palette.length;\n	  c = 0;\n	  for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {\n		ret[pos++] = palette[i];\n		ret[pos++] = palette[i + 1];\n		ret[pos++] = palette[i + 2];\n		ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;\n	  }\n	  return ret;\n	};\n\n	PNG.prototype.copyToImageData = function(imageData, pixels) {\n	  var alpha, colors, data, i, input, j, k, length, palette, v, _ref;\n	  colors = this.colors;\n	  palette = null;\n	  alpha = this.hasAlphaChannel;\n	  if (this.palette.length) {\n		palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();\n		colors = 4;\n		alpha = true;\n	  }\n	  data = imageData.data || imageData;\n	  length = data.length;\n	  input = palette || pixels;\n	  i = j = 0;\n	  if (colors === 1) {\n		while (i < length) {\n		  k = palette ? pixels[i / 4] * 4 : j;\n		  v = input[k++];\n		  data[i++] = v;\n		  data[i++] = v;\n		  data[i++] = v;\n		  data[i++] = alpha ? input[k++] : 255;\n		  j = k;\n		}\n	  } else {\n		while (i < length) {\n		  k = palette ? pixels[i / 4] * 4 : j;\n		  data[i++] = input[k++];\n		  data[i++] = input[k++];\n		  data[i++] = input[k++];\n		  data[i++] = alpha ? input[k++] : 255;\n		  j = k;\n		}\n	  }\n	};\n\n	PNG.prototype.decode = function() {\n	  var ret;\n	  ret = new Uint8Array(this.width * this.height * 4);\n	  this.copyToImageData(ret, this.decodePixels());\n	  return ret;\n	};\n\n	return PNG;\n\n})();\n\nvar canvasDataEncoder = (function () {\n	function find_best_size(totallen) {\n	  var pixelCount = Math.ceil(totallen / 3) + 2; //2 pixel for length header\n\n      // canvas max width or height\n      var MAX_L = 4096;\n\n      var sqrt = Math.ceil(Math.sqrt(pixelCount));\n      if (sqrt > MAX_L) {\n        return null;\n      }\n\n      var minL = Math.ceil(pixelCount / MAX_L);\n      var minS = 1e9;\n      var bestH = 0, bestW = 0;\n\n      for (var h = minL; h <= sqrt; h++) {\n        var w = Math.ceil(pixelCount / h);\n        var size = w * h;\n        if (size < minS) {\n          minS = size;\n          bestW = w;\n          bestH = h;\n        }\n\n        if (size == pixelCount) {\n          break;\n        }\n      }\n      return {w: bestW, h: bestH};\n    }\n	\n	function encode(canvas, x, y, data, ext) {\n		\"use strict\";\n		// Stringify the data\n		var ctx = canvas.getContext('2d'),\n			quartet,\n			quartets = [],\n			currentX = 0, currentY = 0,\n			i,j;\n\n		var datalen = data.length;\n		var extlen = ext.length;\n		var sizeBuf = new Uint8Array(6);\n		sizeBuf[0] = extlen & 0xff;\n		sizeBuf[1] = extlen >>  8 & 0xff;\n		sizeBuf[2] = datalen & 0xff;\n		sizeBuf[3] = datalen >>  8 & 0xff;\n		sizeBuf[4] = datalen >>  16 & 0xff;\n		sizeBuf[5] = datalen >>  24 & 0xff;\n		\n		quartets.push([sizeBuf[0],sizeBuf[1],sizeBuf[2],255]);\n		quartets.push([sizeBuf[3],sizeBuf[4],sizeBuf[5],255]);\n		\n		// Loop the string and generate quartet pixel data\n		quartet = [];\n		j = 0;\n		for (i = 0; i < extlen + datalen; i++) {\n			if (i < extlen) {\n				quartet.push(ext[i]);\n			} else {\n				quartet.push(data[i-extlen]);\n			}\n			j++;\n\n			if (j >= 3) {\n				j = 0;\n				quartet.push(255);\n				quartets.push(quartet);\n				quartet = [];\n			}\n		}\n\n		// Loop the quartets and paint them!\n		for (i = 0; i < quartets.length; i++) {\n			quartet = quartets[i];\n			ctx.fillStyle = 'rgba(' + quartet[0] + ', ' + quartet[1] + ', ' + quartet[2] + ', 255)';\n			ctx.fillRect(x + currentX, y + currentY, 1, 1);\n\n			currentX++;\n			if (currentX >= canvas.width) { currentX = 0; currentY++; }\n		}\n	}\n\n	function decodeData(imageData) {\n		\"use strict\";\n		if (imageData.length < 8) {\n			console.log(\"img decode failed!\");\n			return null;\n		}\n		var extlen =\n			imageData[0] << 0 |\n			imageData[1] << 8;\n		var datalen =\n			imageData[2] << 0 |\n			imageData[4] << 8 |\n			imageData[5] << 16 |\n			imageData[6] << 24;\n			\n		var ext = new Uint8Array(extlen);\n		var data = new Uint8Array(datalen);\n		var p = 0, i = 8, j = 0;\n		while (p < extlen) {\n			j++;\n			if (j <= 3) {\n				ext[p++] = imageData[i++];\n			} else {\n				j = 0;\n				i++;\n			}\n		}\n		p = 0;\n		while (p < datalen) {\n			j++;\n			if (j <= 3) {\n				data[p++] = imageData[i++];\n			} else {\n				j = 0;\n				i++;\n			}\n		}\n		return {ext:ext, data:data};\n	}\n	\n	function decode(canvas, x, y) {\n		\"use strict\";\n		var ctx = canvas.getContext('2d'),\n			imageData = ctx.getImageData(x, y, canvas.width, canvas.height).data;\n\n		return decodeData(imageData);\n	}\n\n	return {find_best_size:find_best_size, encode:encode, decode:decode, decodeData:decodeData};\n}());\n\nvar module;\nif (module) module.exports = canvasDataEncoder;\nfunction Uint8ArrayToString(fileData){\n  var dataString = \"\";\n  for (var i = 0; i < fileData.length; i++) {\n    dataString += String.fromCharCode(fileData[i]);\n  }\n \n  return dataString;\n}\n\nasync function output(size, data, os) {\n  if (data.length < size) {\n    // TODO: error handler\n    console.warn('bad size');\n    os.close();\n    return;\n  }\n  os.enqueue(data);\n\n  os.close();\n  return -1;  // success\n}\n\nasync function proxy(req, item) {\n  // TODO: choose fastest node, error retry\n  let cdn = item.cdn;\n  let url = item.url;\n\n  if (cdn == \"\") {\n	  let res = await fetch(url);\n	  return res;\n  }\n  \n  let res = await fetch(cdn);\n  let ab = await res.arrayBuffer();\n  let imgarr = new Uint8Array(ab);\n  let png = new PNG(imgarr);\n  let imgdata = png.decode();\n  let obj = canvasDataEncoder.decodeData(imgdata);\n  \n  if (!obj) {\n    let html = '500: Decode Failed';\n    return new Response(html, {\n      status: 500,\n      statusText: 'Decode Failed'\n    });\n  }\n  let extStr = Uint8ArrayToString(obj.ext);\n  let ext = JSON.parse(extStr);\n  let data = obj.data;\n  let size = ext.size;\n  let mime = ext.mime;\n\n  // http respond\n  let headers = new Headers();\n  headers.set('content-type', mime);\n  headers.set('x-proxy', cdn);\n\n  // ostream <- my chunks\n  // istream -> Response\n  let os;\n  let is = new ReadableStream({\n    start(controller) {\n      os = controller;\n    }\n  });\n\n  res = new Response(is, {\n    headers: headers,\n  });\n\n  output(size, data, os);\n  return res;\n}\n\nexports.onfetch = function(e) {\n  let req = e.request;\n  let url = new URL(req.url);\n\n  let host = url.hostname;\n  if (host != \"percent73.xyz\") {\n	  let res = fetch(url);\n	  return res;\n  }\n  \n  let path = url.pathname;\n  if (path.endsWith('/')) {\n    path += 'index.html';\n  }\n\n  let item = URL_MAP[path.substr(1)];\n  if (!item) {\n    let html = '404: Not Found';\n\n    return new Response(html, {\n      status: 404,\n      statusText: 'Not Found'\n    });\n  }\n\n  return proxy(req, item);\n};\n\nexports.oninit = function(e) {\n  console.log('mod oninit');\n};\n\nexports.onterm = function(e) {\n  console.log('mod onterm');\n};;;;"
var SW_LOADER  = "/* run in service worker */\nconst EVENT_FETCH = 0;\nconst EVENT_MSG = 1;\n\nlet queue = [];\nlet swMod;\n\nfunction addQueue(v) {\n  queue.push(v);\n}\n\nfunction flushQueue() {\n  queue.forEach(args => {\n    let [type, e, y, n] = args;\n\n    switch (type) {\n    case EVENT_MSG:\n      swMod.onmsg(e);\n      break;\n\n    case EVENT_FETCH:\n      let p = swMod.onfetch(e);\n      if (!p) {\n        // sw bypass\n        p = fetch(e.request);\n      }\n      p.then(y).catch(n);\n      break;\n    }\n  });\n  queue = [];\n}\n\nself.onmessage = function(e) {\n  if (swMod) {\n    swMod.onmsg(e);\n  } else {\n    addQueue([EVENT_MSG, e]);\n  }\n};\n\nself.onfetch = function(e) {\n  let req = e.request;\n  let url = req.url;\n\n  console.log('[sw_loader] fetch {mode: %o, url: %o, hdr: %o}',\n    req.mode, url, new Map(req.headers)\n  );\n\n  // force update\n  if (url.endsWith('/--update')) {\n    load(true);\n    let res = new Response('UPDATED');\n    e.respondWith(res);\n    return;\n  }\n\n  // bypass Mixed-Content (except localhost)\n  if (url.startsWith('http:') && !url.startsWith('http://127.0.0.1')) {\n    return;\n  }\n\n  let ret;\n\n  if (swMod) {\n    ret = swMod.onfetch(e);\n  } else {\n    ret = new Promise((y, n) => {\n      addQueue([EVENT_FETCH, e, y, n]);\n    });\n  }\n\n  if (ret) {\n    e.respondWith(ret);\n  }\n};\n\nself.onactivate = function(e) {\n  console.log('[sw_loader] onactivate');\n};\n\nself.oninstall = function(e) {\n  console.log('[sw_loader] oninstall');\n  skipWaiting();\n};\n\nfunction run(code) {\n  let exports = {};\n\n  let fn = Function('exports', code);\n  fn(exports);\n\n  if (swMod) {\n    swMod.onterm();\n  }\n  swMod = exports;\n  swMod.oninit();\n\n  flushQueue();\n}\n\nfunction extractSwMain(code) {\n  let m = code.match(/\\;{3}.+?\\;{3}/);\n  return m && m[0]\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\\"/g, '\"')\n    .replace(/\\\\\\\\/g, '\\\\')\n}\n\nasync function load(isUpdate) {\n  let oldJs;\n  let cache = await caches.open('v1');\n  let req = new Request('/sw_main');\n  let res = await cache.match(req);\n\n  if (res) {\n    oldJs = await res.text();\n  } else {\n    // if cache missing, we use the default\n    // module which defined in boot.js\n    oldJs = SW_MAIN;\n  }\n\n  // init\n  if (!isUpdate) {\n    run(oldJs);\n    return;\n  }\n\n  // fetch latest version\n  let url = location.href;\n  if (isUpdate) {\n    url += '?_=' + Date.now();\n  }\n  res = await fetch(url);\n\n  // cache & run if sw_main modified\n  let newJs = await res.text();\n  let newSw = extractSwMain(newJs);\n  console.assert(newSw);\n\n  if (newSw !== SW_MAIN) {\n    cache.put(req, new Response(newSw));\n    run(newSw);\n    console.log('[sw_loader] sw_main updated');\n  } else {\n    console.log('[sw_loader] sw_main no updated');\n  }\n}\n\nload();"
var SW_INSTALL = "/* run in page */\n\nfunction reload() {\n  var curr = +new Date;\n  var last;\n  try {\n    last = +sessionStorage._ts || 0;\n  } catch (err) {\n    last = curr;\n  }\n\n  if (curr - last < 100) {\n    show('waiting...');\n    setTimeout(reload, 5000);\n    return;\n  }\n\n  try {\n    sessionStorage._ts = curr;\n  } catch (err) {\n  }\n  location.reload();\n}\n\nfunction show(s) {\n  var node = document.body || document.documentElement;\n  node.innerHTML = s;\n}\n\nfunction unsupport() {\n  show('Please use the latest Chrome');\n}\n\nfunction onfail(err) {\n  show(err);\n}\n\nfunction main() {\n  var sw = navigator.serviceWorker;\n  if (!sw) {\n    return unsupport();\n  }\n\n  var asynFlag;\n  try {\n    asynFlag = eval('async _=>_');\n  } catch(err) {\n  }\n\n  var streamFlag = self.ReadableStream;\n  //...\n\n  if (!asynFlag || !streamFlag) {\n    unsupport();\n    return;\n  }\n\n  let url = document.currentScript.src;\n  sw\n    .register(url)\n    .then(reload)\n    .catch(onfail);\n\n  sw.onerror = function(err) {\n    console.warn('sw err:', err);\n  };\n  \n}\nmain();"

eval(self.window ? SW_INSTALL : SW_LOADER);